---
title: <center> <h1>app.R_Markdown</h1> </center>
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


This document was created to allow for an easy comprehension of the app.R code for the PubMed-Search app. The code is divided by sections and each section is explained.

First off we need to set the working directory. This will allow the main code to retrieve files and functions within the directory. 
```{r}
# setwd("~/Text-Mining-with-R/Text_mining_project")
setwd("/home/francois/Documents/Projet_Text_mining/Text-Mining-with-R/Web_app/")
```

Next step is to have all functionning libraries installed and ready to go.Tthis is what we have done in the code chunk below.
```{r, message=FALSE}
library(shiny)
library(topicmodels)
library(dplyr)
library(data.table)
library(easyPubMed)
library(XML)
library(quanteda)
library(tm)
library(foreach)
library(doParallel)
library(DT)
```

In the following section, the main dataframe "df" which contains all the information about each document (Abstract, Authors, Title, etc.) is imported as well as the data files generated by the main code. These files are the LSA and the LDA outputs on which we will perform the query process in order to find the abstracts positions. 
```{r,echo = FALSE}
df <- readRDS("/home/francois/Documents/Projet_Text_mining/Text-Mining-with-R/Web_app/Data/Dataframe") # row data
irlba <- readRDS("/home/francois/Documents/Projet_Text_mining/Text-Mining-with-R/Web_app/Data/irlba") # SVD matrix (for LSA)

ap_documents <- readRDS("/home/francois/Documents/Projet_Text_mining/Text-Mining-with-R/Web_app/Data/LDAdoc") # for LDA
ap_top_terms <- readRDS("/home/francois/Documents/Projet_Text_mining/Text-Mining-with-R/Web_app/Data/LDAtop_terms")
```


This "String" element was created in order to regroup all output strings for easy access and in prevision for the implementation of different languages for the app.
```{r}
Strings <- data.frame(  "noPosQuery" = "Your positive querry isn't significant in any of our topics, try an other research"
                      , "noNegQuery" = "Sorry, we will not take into account the negative request"
                      , "insignificantNegQuery" = "Your negative querry isn't significant in any of our topics, try an other research or continue")

```


For the following sections, a basic knowledge of the RCRAN:shiny library is needed. Basically in order for the shiny app to work properly, it requires two elements: 

- the "ui" or user interface which groups all the interactive widgets and the layout of the app,

- and the "server" which consists of the server logic that defines the behavior of the app.

In our user interface, we have set the layout to be divided in a sidebar and a main page. The sidebar is where the user enters the query inputs as well as the selected method of search. The main page, is where a list of relevant abstracts and other info will be displayed.
Note that a css file containing the display properties is called in the beginning of this section (theme = "stylesheet.css").
```{r}
############################## User Interface ##############################
ui <- fluidPage(id = "fluidpage", theme = "stylesheet.css",
  hr(id="header"),
  div(style="display:inline-block; position: relative; left: 90px",titlePanel("Search")),
  div(style="display:inline-block; position: relative; top: -8px; left: 95px",
      img(id="pubmed_img",src = "PubMed.png", height = 52, width = 150)),
  sidebarLayout(
    
    #side panel ---------------------
    sidebarPanel(id = "sidebarpanel",width = 3,
      textInput("positive_query","Positive query:",value = "protein"),
      textInput("negative_query","Negative query:",value = ""),
      helpText("The negative query allows you to avoid certain topics."),
      br(),
      selectInput("method", 
                  label = "Select your search method:",
                  choices = c("Latent Semantic Analysis", "Latent Dirichlet Allocation"),
                  selected = "Latent Semantic Analysis",
                  width = 250),
      hr(),
      helpText(em("for more information visit https://github.com/Option10/Text-Mining-with-R"),
               align = "center"),
      textOutput("error") # marche que sur LDa pour l'instant
    ),
    
    
    # Main panel --------------------
    mainPanel(id = "mainpage",
      textOutput("environment"),
      conditionalPanel(condition="$('html').hasClass('shiny-busy')",
                       tags$div("Loading...",id="loadmessage")),
      DTOutput("table")
    )
  )
)
```



We now enter the core of the app: the server logic. Like previously mentioned, here is where the behavior of the app will be defined. The server is a type function that accepts the "input" and "output" arguments. In this section, we will proceed to the actual query processing, the output will be the list of abstracts of interest stored in a spacial Datatable (DT library).
Note that the query systems are computed within a "renderPrint({ ... })" environment, this is to enable the app to be aware of changes of the input variables and thus react accordingly.

We start by defining our "Results" variable which is a list that will contain the indices of the abstracts of interest. Next we call the query function respective to each method. Depending on the User's choice of method, the query system will be applied either to the irlba matrix (for LSA) or the ap_top_terms and ap_documents matrices (for the LDA). As mentioned before, the query system will return the "Results" variable which is a list containing the indices of the abstracts of interest within de raw dataframe "df". The next step is to retrieve these abstracts (see "output Table:" section) we build a temporary data table "DT" containing the information regarding the abstracts of interest.

Next, we define a new datatable "DT" that contains all the info but stored in a special Datatable (from DT library). This data table will be printed in the main page showing the first 25 documents as well as some other useful features like a search bar, different pages and more. As you can see, the DT::datatable() function accepts different options to modify the output layout, one of which is the "callback" option that contains a Javascript code section that allows to expand the abstract panel under each title.

Finally, the newly created DT will be sent it to an output object that can be handled by the user interface.
```{r}
############################## Server logic ##############################
server <- function(input, output) {
  
  output$environment <- renderPrint({ 
  
    Result <- 0

##############  LSA
    if (input$method == "Latent Semantic Analysis") {
      query_system <- dget("Source/LSA_query_system.R")
      
      if (sum(which(rownames(irlba$v) == "hepatic")) > 0){
        stemming <- FALSE
      }else{stemming <- TRUE}
      
      query_output <- query_system(irlba,input$positive_query,input$negative_query,
                                   df$Abstract,stemming)
      Result <- query_output$res
      error <- query_output$err
      output$error <- renderText({error})
      
    } # end if LSA
    
##############  LDA
    if (input$method == "Latent Dirichlet Allocation") {
      query_system <- dget("Source/LDA_query_system.R")
      if (sum(which(ap_top_terms$term == "hepatic")) > 0){
        stemming <- FALSE
      }else{stemming <- TRUE}
      
      query_output <- query_system(input$positive_query,input$negative_query,
                                   ap_top_terms,ap_documents,df$Abstract,Strings,stemming)
      Result <- query_output$res
      error <- query_output$err
      output$error <- renderText({error})
      
    } # end if LDA
    
################# Output Table: 
    
    # create dataframe
    if (!is.null(Result)){
      DT = data.table(
        Title = df$Title[Result],
        Abstract = df$Abstract[Result],
        ID = paste("<a href='https://www.ncbi.nlm.nih.gov/pubmed/?term=",df$ID[Result],
                   "'>",df$ID[Result],"</a>",sep = ""),
        Date = as.Date(as.character(df$Date[Result]),format = "%Y"),
        Authors = gsub("/", ", ", df$Authors[Result]))
    }else{
      DT = data.table(
        Title = NA,
        Abstract = NA,
        ID = NA,
        Date = NA,
        Authors = NA)
    }
    # create dataframe output with DT::datatable and renderDT 
    DT<- datatable(cbind(' ' = '&oplus;', DT), escape = FALSE,
                   options = list(
                     pageLength = 25,
                     columnDefs = list(
                       list(visible = FALSE, targets = c(3,4)),
                       list(width = '65px', targets = 5),
                       list(orderable = FALSE, className = 'details-control', targets = 1),
                       list(orderable = TRUE, className = 'details-control', targets = 0)),
                     searchHighlight = TRUE),
                   callback = JS("
                      table.column(1).nodes().to$().css({cursor: 'auto'});
                      var format = function(d) {
                        return '<div style=\"background-color:#eee; padding: .5em;\"> Abstract: ' +
                                d[3] + '</div>' +
                               '<div style=\"background-color:#eee; padding: .5em;\"> ID: '+ d[4] +
                               '</div>';
                      };
                      table.on('click', 'td.details-control', function() {
                        var td = $(this), row = table.row(td.closest('tr'));
                        if (row.child.isShown()) {
                          row.child.hide();
                          td.html('&oplus;');
                        } else {
                          row.child(format(row.data())).show();
                          td.html('&CircleMinus;');
                        }
                      });"))
    # render output
    output$table <- renderDT(DT)
    
  }) # end Render environement
  
} # end server function
```


```{r}
# Run the app --------------------
shinyApp(ui = ui, server = server)
```
